---
title: "population genetics analysis Mlp"
output: html_notebook
---

## Author: Ammar Abdalrahem

------------------------------------------------------------------------

## 1. Dependencies

Remember to re-run this code every time you re-open this R Notebook.

```{r, echo=FALSE}
#Code to install packages if necessary, and read them with library function

required_packages <- c("knitr","ggplot2","readxl","tidyverse","genepop","hierfstat","here","mapdata",
                       "mapplots","data.table","grDevices","colorspace","adegenet","poppr","pegas","ape","ade4","remotes","ggtree","ggtreeExtra")
for (package in required_packages) {
  if (package %in% row.names(installed.packages())) {
    library(package, character.only = TRUE)
  } else {
    install.packages(package)
    library(package, character.only = TRUE)
  }
}

```



## 2. Obtain data


```{r, echo=FALSE}
# get the path of the current R script
path <- dirname(rstudioapi::getSourceEditorContext()$path)

# set the working directory to the path of the current R script
setwd(path)

# check the current working directory
getwd()


# import the data within specified sheet
data <- read_excel("SexAsex4Ammar.xlsx", 
                  sheet = "Ammar")

#covert data to data frame
data <- as.data.frame(data)


# Remove rows containing "sex" in "Profil" except for those sampled at "Prelles"
#data <- data[!(data$Profil == "sex" & !grepl("Prelles", data$Site, ignore.case = TRUE)), ]

# remove unknown Profil & population
data <- data[!(data$Pop == "NA"), ]
#take a look to data

head(data)

```


## 3. Define MLG and MLL

```{r}
#create table of genotype

# Select columns with "Mlp" in the name and the first column as isolate id
genotype_cols <- c("Isolate", grep("Mlp", names(data), value = TRUE))
genotype_data <- data[, genotype_cols]

#make isolate id as column names 
rownames(genotype_data) <- genotype_data[,1]
#delete the first column
genotype_data$Isolate = NULL


# Convert to genind object
data_GenInd <- df2genind(
  X = genotype_data,   #data.frame containing allele data only 
  sep = NULL,
  ncode = 3,           #an optional integer giving the number of characters used for coding one genotype at one locus.
  ind.names = rownames(genotype_data),  # individuals names
  loc.names = colnames(genotype_data),  # markers names
  pop = data$Pop,                       # giving the population of each individual
  NA.char = "999",                      # string corresponding to missing allele 999 or 999999
  ploidy = 2,
  type = "codom",                       #codom' stands for 'codominant' (e.g. microstallites, allozymes)
  strata = NULL,
  hierarchy = NULL,
  check.ploidy = getOption("adegenet.check.ploidy")
)

data_Genclone <- as.genclone(data_GenInd)

#Define MLG according threshold = 0
mlg_assignments <- mlg.filter(data_Genclone, threshold = 0, distance = "diss.dist", threads = 1L,missing = "asis") 
#he "asis" option is used to indicate that missing data should be treated "as is," meaning that missing values will be retained as NA in the distance matrix.

#add MLG result to the table
genotype_data$MLG <- mlg_assignments

#Define the MLL 
#Choosing a threshold
#After you have chosen a genetic distance and a filtering algorithm
#choose threshold to represent the minimum genetic distance at which two individuals would be considered from different clonal lineages.

data_filtered <-filter_stats(data_Genclone, distance = diss.dist, plot = TRUE, missing = "asis")
# “farthest neighbor” algorithm.
#Arnaud-Haond et al. 2007, @bailleul2016rclone
print(farthest_thresh <- cutoff_predictor(data_filtered$farthest$THRESHOLDS))

# “UPGMA ” algorithm.
print(average_thresh  <- cutoff_predictor(data_filtered$average$THRESHOLDS))

# “nearest neighbor” algorithm.
print(nearest_thresh  <- cutoff_predictor(data_filtered$nearest$THRESHOLDS))


#Define the MLL threshold 0.5, algorithm	Farthest neighbor

mll_assignments<- mlg.filter(data_Genclone, threshold = average_thresh , algorithm = "average_neighbor" , distance = "diss.dist", threads = 1L, missing = "asis" ) 

genotype_data$MLL_poppr <- mll_assignments

#clean
rm(data_Genclone, data_filtered) 


#write.csv2(genotype_data, "data_new.csv")

```




## Identification the individuals profile(sex/asex) (two clusters)

```{r}
# First identification by cluster
grp <- find.clusters(data_GenInd, method = "kmeans", stat = "BIC", n.pca= 90 , n.clust= 2, n.iter=100000, n.start=100)
cluster_assignments <- grp$grp
genotype_data$cluster <- cluster_assignments

dapc1 <- dapc(data_GenInd, grp$grp, n.pca= 90 , n.clust=2, n.da = 100)


# results visualization  
scatter(dapc1)
compoplot(dapc1, posi="bottomright", txt.leg=paste("Cluster", 1:2), lab="", ncol=1, xlab="individuals")

#found special individual 
# Convert the posterior probabilities to a data frame
posterior_data <- as.data.frame(dapc1$posterior)

# Add individual names as a column in the data frame
posterior_data$Individual <- rownames(posterior_data)

# Melt the data frame for visualization
melted_data <- reshape2::melt(posterior_data, id.vars = "Individual", variable.name = "Cluster", value.name = "Probability")

# Create a scatter plot with individual names as labels
ggplot(melted_data, aes(x = Cluster, y = Probability, color = Cluster, label = Individual)) +
  geom_point() +
  xlab("Cluster") +
  ylab("Probability") +
  labs(color = "Cluster") +
  theme_minimal() +
  geom_text(nudge_y = 0.02)  # Add labels slightly above the data points


#reomve uncertin cluster
# Assuming you have stored the posterior probabilities in a variable named 'posterior'
# Subset the main table to include only individuals with probability 1.00 in either cluster
certain_data <- data[posterior_data[, 1] >= 0.8 | posterior_data[, 2] >= 0.8 , ]


# Create a new table for uncertain individuals
uncertain_data <- data[!(posterior_data[, 1] >= 0.8 | posterior_data[, 2] >= 0.8), ]

genotype_data$Cluster <- ifelse(posterior_data[, 1] >= 0.8, "Cluster 1", #80% 
                       ifelse(posterior_data[, 2] >= 0.8, "Cluster 2", 
                              ifelse(posterior_data[, 1] > posterior_data[, 2], 
                                     "Cluster 1 (Closer to Cluster 2)", 
                                     ifelse(posterior_data[, 2] > posterior_data[, 1], 
                                            "Cluster 2 (Closer to Cluster 1)", 
                                            "None Determined"))))



#Remove uncertain_data

#genotype_data <- subset(genotype_data, Cluster %in% c("Cluster 1", "Cluster 2"))

#remove 
genotype_data$cluster = NULL

rm(certain_data, melted_data,dapc1,uncertain_data ,posterior_data, grp) 


```



##G/N and Fis calculation for cluster groups

```{r}
#create table of genotype

# Select columns with "Mlp" in the name and the first column as isolate id
genotype_cols <- c(grep("Mlp", names(genotype_data), value = TRUE))
genotype_mlp <- data[, genotype_cols]

#make isolate id as column names 
rownames(genotype_mlp) <- rownames(genotype_data)


# Convert to genind object
data_GenInd_Cluster <- df2genind(
  X = genotype_mlp,   #data.frame containing allele data only 
  sep = NULL,
  ncode = 3,           #an optional integer giving the number of characters used for coding one genotype at one locus.
  ind.names = rownames(genotype_mlp),  # individuals names
  loc.names = colnames(genotype_mlp),  # markers names
  pop = genotype_data$Cluster,                       # giving the population of each individual
  NA.char = "999",                      # string corresponding to missing allele 999 or 999999
  ploidy = 2,
  type = "codom",                       #codom' stands for 'codominant' (e.g. microstallites, allozymes)
  strata = NULL,
  hierarchy = NULL,
  check.ploidy = getOption("adegenet.check.ploidy")
)

Nb_Pop = length(levels(data_GenInd_Cluster@pop))

# Attribution des différents vecteurs que l'on souhaite calculer
N <- vector(mode ="integer", length = Nb_Pop)
GsurN<- vector(mode ="numeric", length = Nb_Pop)
Ho <- vector(mode ="numeric", length = Nb_Pop)
Hs <- vector(mode ="numeric", length = Nb_Pop)
Fis <- vector(mode ="numeric", length = Nb_Pop)
rbarD<- vector(mode ="numeric", length = Nb_Pop)

Pop <- levels(data_GenInd_Cluster$pop)

## Utilisation de Poppr pour récupérer les premiers indices N, G/N et rbarD
Table_PPR <- poppr(data_GenInd_Cluster) # marche bien

rbarD <- Table_PPR$rbarD[1:Nb_Pop]
N <- Table_PPR$N[1:Nb_Pop]
GsurN <- (Table_PPR$MLG[1:Nb_Pop]-1)/(Table_PPR$N[1:Nb_Pop]-1)

#calcul de la proba de DL
ProbaLD <- vector(mode ="numeric", length = Nb_Pop)
for (i in 1:Nb_Pop) {
  i=1
  Temp_Sample <- popsub(data_GenInd_Cluster, Table_PPR$Pop[i])
  ProbaLD[i] = ia(Temp_Sample, sample = 999, plot = F)[4] # Attention c'est assez long à tourner 
}


## Utilisation de Fstat pour calculer les autres indices HO, HE, Fis et Ar

data_Fstat <-genind2hierfstat(data_GenInd_Cluster)

# Boucles qui permet de calculer les indices souhaités pour chaque population (et pas la globalité)
a =0
for (i in levels(data_Fstat$pop) ){
  Poptmp <- data_GenInd_Cluster[which(data_GenInd_Cluster$pop==i),]
  #Poptmp  <-genind2hierfstat(Poptmp)
  fstat_basic_Temporel <- basic.stats(Poptmp)
  a = a+1
  Ho[a]<-fstat_basic_Temporel$overall["Ho"]  
  Hs[a]<-fstat_basic_Temporel$overall["Hs"]  
  Fis[a]<-fstat_basic_Temporel$overall["Fis"] 
}

# calcul de la richess allélique
Obj_Ar <- allelic.richness(data_Fstat[which(data_Fstat[,"pop"]!="NA"),])
Ar_per_loc <- Obj_Ar$Ar
#Ar_per_loc <- Ar_per_loc[c(1:2, 4:13, 15:23),] # pour sortir les locus 100 et 26 qui sont absents de certaines pops
Ar<- vector(mode ="numeric", length = Nb_Pop)
for (i in 1:Nb_Pop){ 
  Ar[i] = mean(Ar_per_loc[,i])
}

## Mise en forme du tableau final
Tab_Indices_per_pop <- rbind(N, GsurN, Ar, Ho, Hs, Fis, rbarD)
colnames(Tab_Indices_per_pop) <- Pop
Tab_Indices_per_pop <- t(Tab_Indices_per_pop)
kable(Tab_Indices_per_pop, digits = 3)


# Tab_Indices_per_pop is the dataframe containing the results
# Loop through each row of the dataframe
for (i in 1:nrow(Tab_Indices_per_pop)) {
  cluster_name <- rownames(Tab_Indices_per_pop)[i]  # Get the cluster name
  
  # Check if the Fis value is negative
  if (Tab_Indices_per_pop[i, "Fis"] < 0) {
    # If Fis is negative, set the "Reproduction" column to "clonal" for the corresponding cluster
    genotype_data$Reproduction[genotype_data$Cluster == cluster_name] <- "clonal"
  } else {
    # If Fis is non-negative, set the "Reproduction" column to "sex" for the corresponding cluster
    genotype_data$Reproduction[genotype_data$Cluster == cluster_name] <- "sex"
  }
}

```

##G/N and Fis calculation for Mll for clonal group

```{r}
#create table of genotype

# Select columns with "Mlp" in the name and the first column as isolate id

clonal_data <- genotype_data[genotype_data$Reproduction == "clonal", ]

# Select columns with "Mlp" in the name and the first column as isolate id
genotype_cols_clonal <- c(grep("Mlp", names(clonal_data), value = TRUE))
genotype_clonal <- clonal_data[, genotype_cols_clonal]

#make isolate id as column names 
rownames(genotype_clonal) <- rownames(clonal_data)



# Convert to genind object
data_GenInd_clonal_MLL <- df2genind(
  X = genotype_clonal,   #data.frame containing allele data only 
  sep = NULL,
  ncode = 3,           #an optional integer giving the number of characters used for coding one genotype at one locus.
  ind.names = rownames(genotype_clonal),  # individuals names
  loc.names = colnames(genotype_clonal),  # markers names
  pop = clonal_data$MLL,                       # giving the population of each individual
  NA.char = "999",                      # string corresponding to missing allele 999 or 999999
  ploidy = 2,
  type = "codom",                       #codom' stands for 'codominant' (e.g. microstallites, allozymes)
  strata = NULL,
  hierarchy = NULL,
  check.ploidy = getOption("adegenet.check.ploidy")
)
data_Genclone_clonal <- as.genclone(data_GenInd_clonal_MLL)

data_sex_filtered <-filter_stats(data_Genclone_clonal, distance = diss.dist, plot = TRUE, missing = "asis")

Nb_Pop = length(levels(data_GenInd_clonal_MLL@pop))

# Attribution des différents vecteurs que l'on souhaite calculer
N <- vector(mode ="integer", length = Nb_Pop)
GsurN<- vector(mode ="numeric", length = Nb_Pop)
Ho <- vector(mode ="numeric", length = Nb_Pop)
Hs <- vector(mode ="numeric", length = Nb_Pop)
Fis <- vector(mode ="numeric", length = Nb_Pop)
rbarD<- vector(mode ="numeric", length = Nb_Pop)

Pop <- levels(data_GenInd_clonal_MLL$pop)

## Utilisation de Poppr pour récupérer les premiers indices N, G/N et rbarD
Table_PPR <- poppr(data_GenInd_clonal_MLL) # marche bien

rbarD <- Table_PPR$rbarD[1:Nb_Pop]
N <- Table_PPR$N[1:Nb_Pop]
GsurN <- (Table_PPR$MLG[1:Nb_Pop]-1)/(Table_PPR$N[1:Nb_Pop]-1)

#calcul de la proba de DL
ProbaLD <- vector(mode ="numeric", length = Nb_Pop)
for (i in 1:Nb_Pop) {
  i=1
  Temp_Sample <- popsub(data_GenInd_clonal_MLL, Table_PPR$Pop[i])
  ProbaLD[i] = ia(Temp_Sample, sample = 999, plot = F)[4] # Attention c'est assez long à tourner 
}


## Utilisation de Fstat pour calculer les autres indices HO, HE, Fis et Ar

data_Fstat <-genind2hierfstat(data_GenInd_clonal_MLL)

# Boucles qui permet de calculer les indices souhaités pour chaque population (et pas la globalité)
a =0
for (i in levels(data_Fstat$pop) ){
  Poptmp <- data_GenInd_clonal_MLL[which(data_GenInd_clonal_MLL$pop==i),]
  #Poptmp  <-genind2hierfstat(Poptmp)
  fstat_basic_Temporel <- basic.stats(Poptmp)
  a = a+1
  Ho[a]<-fstat_basic_Temporel$overall["Ho"]  
  Hs[a]<-fstat_basic_Temporel$overall["Hs"]  
  Fis[a]<-fstat_basic_Temporel$overall["Fis"] 
}

# calcul de la richess allélique
Obj_Ar <- allelic.richness(data_Fstat[which(data_Fstat[,"pop"]!="NA"),])
Ar_per_loc <- Obj_Ar$Ar
#Ar_per_loc <- Ar_per_loc[c(1:2, 4:13, 15:23),] # pour sortir les locus 100 et 26 qui sont absents de certaines pops
Ar<- vector(mode ="numeric", length = Nb_Pop)
for (i in 1:Nb_Pop){ 
  Ar[i] = mean(Ar_per_loc[,i])
}

## Mise en forme du tableau final
Tab_Indices_per_pop <- rbind(N, GsurN, Ar, Ho, Hs, Fis, rbarD)
colnames(Tab_Indices_per_pop) <- Pop
Tab_Indices_per_mll <- t(Tab_Indices_per_pop)
kable(Tab_Indices_per_mll, digits = 3)

# Assuming 'clonal_data' is your data frame containing MLG and MLL information
mlg_counts <- aggregate(MLG ~ MLL_poppr, data = clonal_data, FUN = function(x) length(unique(x)))
rownames(mlg_counts) <- mlg_counts[,1]

asexual_lineages <- merge(mlg_counts,Tab_Indices_per_mll,by="row.names",all.x=TRUE)



```


##G/N and Fis calculation for Mll for sexual group

```{r}
#create table of genotype

# Select columns with "Mlp" in the name and the first column as isolate id

sex_data <- genotype_data[genotype_data$Reproduction == "sex", ]

# Select columns with "Mlp" in the name and the first column as isolate id
genotype_cols_sex <- c(grep("Mlp", names(sex_data), value = TRUE))
genotype_sex <- sex_data[, genotype_cols_sex]

#make isolate id as column names 
rownames(genotype_sex) <- rownames(sex_data)



# Convert to genind object
data_GenInd_sex_MLL <- df2genind(
  X = genotype_sex,   #data.frame containing allele data only 
  sep = NULL,
  ncode = 3,           #an optional integer giving the number of characters used for coding one genotype at one locus.
  ind.names = rownames(genotype_sex),  # individuals names
  loc.names = colnames(genotype_sex),  # markers names
  pop = NULL,                       # giving the population of each individual
  NA.char = "999",                      # string corresponding to missing allele 999 or 999999
  ploidy = 2,
  type = "codom",                       #codom' stands for 'codominant' (e.g. microstallites, allozymes)
  strata = NULL,
  hierarchy = NULL,
  check.ploidy = getOption("adegenet.check.ploidy")
)


data_Genclone_sex <- as.genclone(data_GenInd_sex_MLL)

data_sex_filtered <-filter_stats(data_Genclone_sex, distance = diss.dist, plot = TRUE, missing = "asis")


rm (Ar_per_loc, asexual_lineages, data_Fstat, data_Genclone_clonal, data_Genclone_sex, data_GenInd_clonal_MLL,
    data_GenInd_Cluster, data_GenInd_sex_MLL, fstat_basic_Temporel,mlg_counts, Obj_Ar, Poptmp , 
    Table_PPR, Temp_Sample)

```



##check the new MLL anf old Mll for asexual

```{r}

clonal_data$mll <- data$Mll[match(row.names(clonal_data), data$Isolate)]
# Create a contingency table
contingency_table_clonal <- table(clonal_data$MLL_poppr, clonal_data$mll)

# Print the contingency table
write.table(contingency_table_clonal, file = "contingency_table_clonal.csv", sep = ",", quote = FALSE)

```


##check the new MLL anf old Mll for sexual
```{r}

sex_data$mll <- data$Mll[match(row.names(sex_data), data$Isolate)]
# Create a contingency table
contingency_table_sex <- table(sex_data$MLL_poppr, sex_data$mll)

# Print the contingency table
write.table(contingency_table_sex, file = "contingency_table_sex.csv", sep = ",", quote = FALSE)


# Find row and column names where values are higher than 3
high_value_indices <- which(contingency_table_sex > 3, arr.ind = TRUE)
high_value_rows <- rownames(contingency_table_sex)[high_value_indices[, 1]]
high_value_cols <- colnames(contingency_table_sex)[high_value_indices[, 2]]
high_values <- contingency_table_sex[high_value_indices]

# Create a new table with row names, column names, and values
high_values_table <- data.frame(RowName = high_value_rows, ColumnName = high_value_cols, Value = high_values)

write.table(high_values_table, file = "contingency_table_sex.csv", sep = ",", quote = FALSE)


```


## create table of repeated Mll diffrent years
```{r}

genotype_data$year <- data$Year[match(row.names(genotype_data), data$Isolate)]

# Calculate the frequency of each MLL-Year combination
repeated_MLL_table <- genotype_data [,c("MLL_poppr","year")]
rownames(repeated_MLL_table) <- NULL
# Rename the columns for clarity
colnames(repeated_MLL_table) <- c("MLL",  "year")



# Create an empty list to store the dictionary
mll_year_dict <- list()

# Loop through each row in the repeated_MLL_table
for (i in 1:nrow(repeated_MLL_table)) {
  mll <- repeated_MLL_table$MLL[i]
  year <- repeated_MLL_table$year[i]
  
  # If the MLL is not yet in the dictionary, add it with the current year
  if (!(mll %in% names(mll_year_dict))) {
    mll_year_dict[[as.character(mll)]] <- list(year)
  } else {
    # If the MLL is already in the dictionary, append the year to its list
    mll_year_dict[[as.character(mll)]] <- c(mll_year_dict[[as.character(mll)]], year)
  }
}

# Print the dictionary
print(mll_year_dict)
mll_year_dict["915"]

# Convert the dictionary to a dataframe
mll_year_df <- data.frame(
  MLL = as.integer(names(mll_year_dict)),
  Years = sapply(mll_year_dict, paste, collapse = ", ")
)



# Create a new column to store the counts
mll_year_df$YearCount <- NA

# Loop through each row in repeated_MLL_table
for (i in 1:nrow(mll_year_df)) {
  # Filter the mll_year_df for the current MLL
  filtered_df <- mll_year_df[mll_year_df$MLL == mll_year_df$MLL[i], ]
  
  # Count how many years are associated with the current MLL
  years_count <- length(unlist(strsplit(filtered_df$Years, ", ")))
  
  # Assign the count to the YearCount column
  mll_year_df$YearCount[i] <- years_count
}

# Loop through each row in repeated_MLL_table
for (i in 1:nrow(repeated_MLL_table)) {
  # Filter the mll_year_df for the current MLL
  filtered_df <- mll_year_df[mll_year_df$MLL == repeated_MLL_table$MLL[i], ]
  
  # Get unique years associated with the current MLL
  unique_years <- unique(unlist(strsplit(filtered_df$Years, ", ")))
  
  # Combine unique years into a single string
  years_string <- paste(unique_years, collapse = ", ")
  
  # Assign the combined years to the Years column in mll_year_df
  mll_year_df[mll_year_df$MLL == repeated_MLL_table$MLL[i], "Years"] <- years_string
}

#remove all non repeated mll  
mll_year_df <- mll_year_df[!(mll_year_df$YearCount == 1), ]

#test
mll_year_df [mll_year_df$MLL == 98, ]


# Print the contingency table
write.table(mll_year_df, file = "filtered_mll_years.csv", sep = ",", quote = FALSE, row.names = FALSE)
```


##corss validation to define Profile

```{r}
for (i in 1:nrow(mll_year_df)) {
  if (mll_year_df$YearCount[i] >= 3) {
    mll <- mll_year_df[mll_year_df$MLL == mll_year_df$MLL[i], ]
    years_string <- mll$Years
    years <- unlist(strsplit(years_string, ", "))
    num_years <- length(unique(years))  # Count unique years
    
    if (num_years >= 2) {
      mll_year_df$profile[i] <- "clonal"
    } else {
      mll_year_df$profile[i] <- "sex"
    }
  } else {
    mll_year_df$profile[i] <- "sex"
  }
}



for (i in 1:nrow(mll_year_df)) {
  mll_value <- mll_year_df$MLL[i]
  profile_value <- mll_year_df$profile[i]
  
  genotype_data$profile[genotype_data$MLL_poppr == mll_value] <- profile_value
}

genotype_data[is.na(genotype_data$profile), "profile"] <- "sex"


```





##  try NJ it with popper
 
```{r}
# Convert to genind object
final_GenInd <- df2genind(
  X = genotype_mlp,   #data.frame containing allele data only 
  sep = NULL,
  ncode = 3,           #an optional integer giving the number of characters used for coding one genotype at one locus.
  ind.names = rownames(genotype_mlp),  # individuals names
  loc.names = colnames(genotype_mlp),  # markers names
  pop = genotype_data$MLL_poppr,                       # giving the population of each individual
  NA.char = "999",                      # string corresponding to missing allele 999 or 999999
  ploidy = 2,
  type = "codom",                       #codom' stands for 'codominant' (e.g. microstallites, allozymes)
  strata = NULL,
  hierarchy = NULL,
  check.ploidy = getOption("adegenet.check.ploidy")
)


# Calculate distance matrix and build NJ tree

dist <- diss.dist(final_GenInd)
tree <- nj(dist)
tree2 <- aboot(final_GenInd, dist = diss.dist , tree = "upgma", missing = "asis")

# Create group information based on 'Profil' column
groupInfo <- split(rownames(genotype_data), genotype_data$profile)

# Group the tree labels based on the group information
tree <- groupOTU(tree2, groupInfo)


# Create the ggtree plot with circular layout
options(ignore.negative.edge=TRUE)
p <- ggtree(tree, aes(color = group),layout = "circular")
p

# Create a dataframe for annotation
dat1 <- data.frame(
  ID = rownames(genotype_data),
  lat = data$Lat,
  long = data$Long,
  MLL = genotype_data$MLL_poppr,
  Group = genotype_data$profile,
  Year = as.factor(data$Year),
  Location = data$Site

)

# Use %<+% of ggtree to add annotation dataset to the tree
p1 <- p %<+% dat1

# Initialize fill scale using new_scale_fill() from ggnewscale package
p2 <- p +
  geom_fruit(
    data = dat1,
    geom = geom_col,
    mapping = aes(y = ID, x = Year, fill = Location),  # Map 'Location' to fill
    pwidth = 0.4,
    offset = 0.01,
    axis.params = list(
      axis = "x",  # Add x-axis text
      text.angle = -45,  # Adjust text angle
      hjust = 0,  # Adjust horizontal position
      text.size = 2.5,
      line.size = 0.4,
      line.color = "black"
    ),
    grid.params = list(color = "black", linetype = 5, size = 0.4, alpha = 0.8)  # Add grid lines
  ) +
  scale_shape_manual(
    values = 1:length(unique(dat1$Location))  # Set shape values
  ) +
  theme(
    #legend.position = c(1.15, 0.5),  # Adjust legend position
    legend.background = element_rect(fill = NA),  # Set legend background
    legend.title = element_text(size = 9),  # Adjust legend title size
    legend.text = element_text(size = 7),  # Adjust legend text size
    legend.spacing.y = unit(0.3, "cm")  # Adjust legend spacing (y orientation)
  ) 
   #+ geom_treescale(fontsize=2, linesize=0.3, x=-10, y=1000)

# Modify legend titles
p2 <- p2 +
  labs(fill = "Location", color = "Profile") 

p2

#ggsave("tree_plot2.png", p2, width = 17, height = 8, dpi = 600)  # Save the plot with desired dimensions



```











## 4. Data map visualization

just to look at where each population is located 

```{r}
# summarize data by population and location

genotype_data$Pop <- data$Pop
genotype_data$Long <- data$Long
genotype_data$Lat <- data$Lat
  

pop_data <- genotype_data %>%
  group_by(Pop, Long, Lat, profile) %>%
  summarize(n = n(), .groups = "drop") %>%   # Specify .groups = "drop" to remove grouping
  mutate(percent = n / sum(n)) %>%
  select(Pop, Long, Lat, profile, n, percent)


#draw map Representative the popular individual across France map within reproductive mode
# The area of the France Region;
xlim <- c(-4.3,9.1)
ylim <- c(41, 51)

# Creates an xyz object for use with the function draw.pie
xyz <- make.xyz(pop_data$Long, pop_data$Lat, pop_data$percent, pop_data$profile)

# Create a color palette based on the unique profile values
unique_profiles <- unique(pop_data$profile)
num_profiles <- length(unique_profiles)
my_colors <- viridis(num_profiles)

# Create a named vector to map profiles to colors
#profile_color_mapping <- setNames(my_colors, unique_profiles)

# Create a named vector for profile colors
profile_color_mapping <- c("clonal" = "#FFEB00",  "sex" = "#FA1421"  )
transparent_colors <- adjustcolor(profile_color_mapping, alpha.f = 0.8)


# The plot of the pie chart above the map
par(mai = c(0.5, 0.5, 0.35, 0.2), omi = c(0.25, 0.5, 0, 0),
    mgp = c(2.5, 0.5, 0), family = "Arial")
basemap(xlim = c(-4.3, 9.1), ylim = c(41, 51), bg = "white",
        main = "Distribution of population of poplar rust in France")
map("france", fill = FALSE, col = "light blue", xlim = xlim, ylim = ylim, add = TRUE)
draw.pie(xyz$x, xyz$y, xyz$z, radius = 0.3, col =transparent_colors)
legend.pie(-4.5, 41.4, labels = c("clonal", "sex"  ),
           radius = 0.3, bty = "n", col = profile_color_mapping, cex = 1, label.dist = 1.5)
```







