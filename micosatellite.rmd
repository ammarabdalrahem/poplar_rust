---
title: "population genetics analysis Mlp"
output: html_notebook
---

## Author: Ammar Abdalrahem

------------------------------------------------------------------------

## 1. Dependencies

Remember to re-run this code every time you re-open this R Notebook.

```{r, echo=FALSE}
#Code to install packages if necessary, and read them with library function

required_packages <- c("knitr","ggplot2","readxl","tidyverse","genepop","hierfstat","here","mapdata",
                       "mapplots","data.table","grDevices","colorspace","adegenet","poppr","pegas","ape",
                       "ade4","remotes","ggtree","ggtreeExtra","viridis","factoextra","openxlsx")
for (package in required_packages) {
  if (package %in% row.names(installed.packages())) {
    library(package, character.only = TRUE)
  } else {
    install.packages(package)
    library(package, character.only = TRUE)
  }
}

```



## 2. Obtain data


```{r, echo=FALSE}
# get the path of the current R script
path <- dirname(rstudioapi::getSourceEditorContext()$path)

# set the working directory to the path of the current R script
setwd(path)

# check the current working directory
getwd()


# import the data within specified sheet
data <- read_excel("SexAsex4Ammar+departements_trail.xlsx", 
                  sheet = "Ammar")

#covert data to data frame
data <- as.data.frame(data)


# Remove rows containing "Sex" in "Profil" except for those sampled at "Prelles"
#data <- data[!(data$Profil == "Sex" & !grepl("Prelles", data$Site, ignore.case = TRUE)), ]

# remove unknown Profil & population
data <- data[!(data$Pop == "NA"), ]
#take a look to data

head(data)

```


## 3. Define MLG and MLL

```{r}
#create table of genotype
#by select columns with "Mlp" in the name and the first column as isolate id
genotype_cols <- c("Isolate", grep("Mlp", names(data), value = TRUE))
genotype_data <- data[, genotype_cols]

#make isolate id as column names 
rownames(genotype_data) <- genotype_data[,1]
#delete the first column
genotype_data$Isolate = NULL


# Convert data to genind object
data_GenInd <- df2genind(
  X = genotype_data,   #data.frame containing allele data only 
  sep = NULL,
  ncode = 3,           #an optional integer giving the number of characters used for coding one genotype at one locus.
  ind.names = rownames(genotype_data),  # individuals names
  loc.names = colnames(genotype_data),  # markers names
  pop = data$Pop,                       # giving the population of each individual
  NA.char = "999",                      # string corresponding to missing allele 999 or 999999
  ploidy = 2,
  type = "codom",                       #codom' stands for 'codominant' (e.g. microstallites, allozymes)
  strata = NULL,
  hierarchy = NULL,
  check.ploidy = getOption("adegenet.check.ploidy")
)

# Convert data to genclone object
data_Genclone <- as.genclone(data_GenInd)

#Define MLG according threshold = 0
mlg_assignments <- mlg.filter(data_Genclone, threshold = 0, distance = "diss.dist", threads = 1L,missing = "asis") 
#he "asis" option is used to indicate that missing data should be treated "as is," meaning that missing values will be retained as NA in the distance matrix.

#add MLG result to the table
genotype_data$MLG <- mlg_assignments

#Define the MLL 
#Choosing a threshold
#After have chosen a genetic distance and a filtering algorithm
#choose threshold to represent the minimum genetic distance at which two individuals would be considered from different Asex lineages.

data_filtered <-filter_stats(data_Genclone, distance = diss.dist, plot = TRUE, missing = "asis",hist= "sturges")


# “farthest neighbor” algorithm.
#Arnaud-Haond et al. 2007, @bailleul2016rclone
print(farthest_thresh <- cutoff_predictor(data_filtered$farthest$THRESHOLDS))

# “UPGMA ” algorithm.
print(average_thresh  <- cutoff_predictor(data_filtered$average$THRESHOLDS))

# “nearest neighbor” algorithm.
print(nearest_thresh  <- cutoff_predictor(data_filtered$nearest$THRESHOLDS))


#Define the MLL threshold 0.5, algorithm	Farthest neighbor

mll_assignments<- mlg.filter(data_Genclone, threshold = average_thresh , algorithm = "average_neighbor" , distance = "diss.dist", threads = 1L, missing = "asis" ) 

genotype_data$MLL_poppr <- mll_assignments


#clean
#rm(data_Genclone, data_filtered) 


#write.csv2(genotype_data, "data_new.csv")

```



## Identification the individuals profile(sex/asex) (two clusters)

```{r}

#create table of genotype

# Select columns with "Mlp" in the name and the first column as isolate id
genotype_cols <- c(grep("Mlp", names(genotype_data), value = TRUE))
genotype_mlp <- data[, genotype_cols]

#make isolate id as column names 
rownames(genotype_mlp) <- rownames(genotype_data)

#need to add rule for n.clust

# First identification by cluster
grp <- find.clusters(data_GenInd, method = "kmeans", stat = "BIC", n.pca= 90 , n.clust= 2, n.iter=100000, n.start=100)
cluster_assignments <- grp$grp
genotype_data$cluster <- cluster_assignments

dapc1 <- dapc(data_GenInd, grp$grp, n.pca= 90 , n.clust=2, n.da = 100)


# results visualization  
scatter(dapc1)
compoplot(dapc1, txt.leg=paste("Cluster", 1:2), lab="", ncol=1, xlab="individuals")

#found special individual 
# Convert the posterior probabilities to a data frame
posterior_data <- as.data.frame(dapc1$posterior)

# Add individual names as a column in the data frame
posterior_data$Individual <- rownames(posterior_data)

# Melt the data frame for visualization
melted_data <- reshape2::melt(posterior_data, id.vars = "Individual", variable.name = "Cluster", value.name = "Probability")

# Create a scatter plot with individual names as labels
ggplot(melted_data, aes(x = Cluster, y = Probability, color = Cluster, label = Individual)) +
  geom_point() +
  xlab("Cluster") +
  ylab("Probability") +
  labs(color = "Cluster") +
  theme_minimal() +
  geom_text(nudge_y = 0.02)  # Add labels slightly above the data points


#reomve uncertin cluster
# Subset the main table to include only individuals with probability >= 0.8 in either cluster
certain_data <- data[posterior_data[, 1] >= 0.8 | posterior_data[, 2] >= 0.8 , ]


# Create a new table for uncertain individuals
uncertain_data <- data[!(posterior_data[, 1] >= 0.8 | posterior_data[, 2] >= 0.8), ]

genotype_data$Cluster <- ifelse(posterior_data[, 1] >= 0.8, "Cluster 1", #80% 
                       ifelse(posterior_data[, 2] >= 0.8, "Cluster 2", 
                                            "None Determined"))



#Remove uncertain_data

#genotype_data <- subset(genotype_data, Cluster %in% c("Cluster 1", "Cluster 2"))

#remove 
genotype_data$cluster = NULL

#rm(certain_data, melted_data,dapc1,uncertain_data ,posterior_data, grp) 


```



##G/N and Fis calculation for cluster groups

```{r}

# Convert to genind object
data_GenInd_Cluster <- df2genind(
  X = genotype_mlp,   #data.frame containing allele data only 
  sep = NULL,
  ncode = 3,           #an optional integer giving the number of characters used for coding one genotype at one locus.
  ind.names = rownames(genotype_mlp),  # individuals names
  loc.names = colnames(genotype_mlp),  # markers names
  pop = genotype_data$Cluster,                       # giving the population of each individual
  NA.char = "999",                      # string corresponding to missing allele 999 or 999999
  ploidy = 2,
  type = "codom",                       #codom' stands for 'codominant' (e.g. microstallites, allozymes)
  strata = NULL,
  hierarchy = NULL,
  check.ploidy = getOption("adegenet.check.ploidy")
)

Nb_Pop = length(levels(data_GenInd_Cluster@pop))

# Attribution des différents vecteurs que l'on souhaite calculer
N <- vector(mode ="integer", length = Nb_Pop)
GsurN<- vector(mode ="numeric", length = Nb_Pop)
Ho <- vector(mode ="numeric", length = Nb_Pop)
Hs <- vector(mode ="numeric", length = Nb_Pop)
Fis <- vector(mode ="numeric", length = Nb_Pop)
rbarD<- vector(mode ="numeric", length = Nb_Pop)

Pop <- levels(data_GenInd_Cluster$pop)

## Utilisation de Poppr pour récupérer les premiers indices N, G/N et rbarD
Table_PPR <- poppr(data_GenInd_Cluster) # marche bien

rbarD <- Table_PPR$rbarD[1:Nb_Pop]
N <- Table_PPR$N[1:Nb_Pop]
GsurN <- (Table_PPR$MLG[1:Nb_Pop]-1)/(Table_PPR$N[1:Nb_Pop]-1)

#calcul de la proba de DL
ProbaLD <- vector(mode ="numeric", length = Nb_Pop)
for (i in 1:Nb_Pop) {
  Temp_Sample <- popsub(data_GenInd_Cluster, Table_PPR$Pop[i])
  ProbaLD[i] = ia(Temp_Sample, sample = 999, plot = F)[4] # Attention c'est assez long à tourner 
}


## Utilisation de Fstat pour calculer les autres indices HO, HE, Fis et Ar

data_Fstat <-genind2hierfstat(data_GenInd_Cluster)

# Boucles qui permet de calculer les indices souhaités pour chaque population (et pas la globalité)
a =0
for (i in levels(data_Fstat$pop) ){
  Poptmp <- data_GenInd_Cluster[which(data_GenInd_Cluster$pop==i),]
  #Poptmp  <-genind2hierfstat(Poptmp)
  fstat_basic_Temporel <- basic.stats(Poptmp)
  a = a+1
  Ho[a]<-fstat_basic_Temporel$overall["Ho"]  
  Hs[a]<-fstat_basic_Temporel$overall["Hs"]  
  Fis[a]<-fstat_basic_Temporel$overall["Fis"] 
}

# calcul de la richess allélique
Obj_Ar <- allelic.richness(data_Fstat[which(data_Fstat[,"pop"]!="NA"),])
Ar_per_loc <- Obj_Ar$Ar
#Ar_per_loc <- Ar_per_loc[c(1:2, 4:13, 15:23),] # pour sortir les locus 100 et 26 qui sont absents de certaines pops
Ar<- vector(mode ="numeric", length = Nb_Pop)
for (i in 1:Nb_Pop){ 
  Ar[i] = mean(Ar_per_loc[,i])
}

## Mise en forme du tableau final
Tab_Indices_per_pop <- rbind(N, GsurN, Ar, Ho, Hs, Fis, rbarD)
colnames(Tab_Indices_per_pop) <- Pop
Tab_Indices_per_pop <- t(Tab_Indices_per_pop)
kable(Tab_Indices_per_pop, digits = 3)


# Tab_Indices_per_pop is the dataframe containing the results
# Loop through each row of the dataframe
for (i in 1:nrow(Tab_Indices_per_pop)) {
  cluster_name <- rownames(Tab_Indices_per_pop)[i]  # Get the cluster name
  
  # Check if the Fis value is negative
  if (Tab_Indices_per_pop[i, "Fis"] < 0) {
    # If Fis is negative, set the "Reproduction" column to "ASex" for the corresponding cluster
    genotype_data$Reproduction[genotype_data$Cluster == cluster_name] <- "Asex"
  } else {
    # If Fis is non-negative, set the "Reproduction" column to "Sex" for the corresponding cluster
    genotype_data$Reproduction[genotype_data$Cluster == cluster_name] <- "Sex"
  }
}

```




##G/N and Fis calculation for Mll for Asex group (as Reproduction)

```{r}
#create table of genotype

# Select columns with "Mlp" in the name and the first column as isolate id

ASex_data <- genotype_data[genotype_data$Reproduction == "Asex", ]

# Select columns with "Mlp" in the name and the first column as isolate id
genotype_cols_ASex <- c(grep("Mlp", names(ASex_data), value = TRUE))
genotype_ASex <- ASex_data[, genotype_cols_ASex]

#make isolate id as column names 
rownames(genotype_ASex) <- rownames(ASex_data)



# Convert to genind object
data_GenInd_ASex_MLL <- df2genind(
  X = genotype_ASex,   #data.frame containing allele data only 
  sep = NULL,
  ncode = 3,           #an optional integer giving the number of characters used for coding one genotype at one locus.
  ind.names = rownames(genotype_ASex),  # individuals names
  loc.names = colnames(genotype_ASex),  # markers names
  pop = ASex_data$MLL_poppr,                       # giving the population of each individual
  NA.char = "999",                      # string corresponding to missing allele 999 or 999999
  ploidy = 2,
  type = "codom",                       #codom' stands for 'codominant' (e.g. microstallites, allozymes)
  strata = NULL,
  hierarchy = NULL,
  check.ploidy = getOption("adegenet.check.ploidy")
)
data_Genclone_ASex <- as.genclone(data_GenInd_ASex_MLL)

data_ASex_filtered <-filter_stats(data_Genclone_ASex, distance = diss.dist, plot = TRUE, missing = "asis")

Nb_Pop = length(levels(data_GenInd_ASex_MLL@pop))

# Attribution des différents vecteurs que l'on souhaite calculer
N <- vector(mode ="integer", length = Nb_Pop)
GsurN<- vector(mode ="numeric", length = Nb_Pop)
Ho <- vector(mode ="numeric", length = Nb_Pop)
Hs <- vector(mode ="numeric", length = Nb_Pop)
Fis <- vector(mode ="numeric", length = Nb_Pop)
rbarD<- vector(mode ="numeric", length = Nb_Pop)

Pop <- levels(data_GenInd_ASex_MLL$pop)

## Utilisation de Poppr pour récupérer les premiers indices N, G/N et rbarD
Table_PPR <- poppr(data_GenInd_ASex_MLL) # marche bien

rbarD <- Table_PPR$rbarD[1:Nb_Pop]
N <- Table_PPR$N[1:Nb_Pop]
GsurN <- (Table_PPR$MLG[1:Nb_Pop]-1)/(Table_PPR$N[1:Nb_Pop]-1)

#calcul de la proba de DL
ProbaLD <- vector(mode ="numeric", length = Nb_Pop)
for (i in 1:Nb_Pop) {
  Temp_Sample <- popsub(data_GenInd_ASex_MLL, Table_PPR$Pop[i])
  ProbaLD[i] = ia(Temp_Sample, sample = 999, plot = F)[4] # Attention c'est assez long à tourner 
}


## Utilisation de Fstat pour calculer les autres indices HO, HE, Fis et Ar

data_Fstat <-genind2hierfstat(data_GenInd_ASex_MLL)

# Boucles qui permet de calculer les indices souhaités pour chaque population (et pas la globalité)
a =0
for (i in levels(data_Fstat$pop) ){
  Poptmp <- data_GenInd_ASex_MLL[which(data_GenInd_ASex_MLL$pop==i),]
  #Poptmp  <-genind2hierfstat(Poptmp)
  fstat_basic_Temporel <- basic.stats(Poptmp)
  a = a+1
  Ho[a]<-fstat_basic_Temporel$overall["Ho"]  
  Hs[a]<-fstat_basic_Temporel$overall["Hs"]  
  Fis[a]<-fstat_basic_Temporel$overall["Fis"] 
}

# calcul de la richess allélique
Obj_Ar <- allelic.richness(data_Fstat[which(data_Fstat[,"pop"]!="NA"),])
Ar_per_loc <- Obj_Ar$Ar
#Ar_per_loc <- Ar_per_loc[c(1:2, 4:13, 15:23),] # pour sortir les locus 100 et 26 qui sont absents de certaines pops
Ar<- vector(mode ="numeric", length = Nb_Pop)
for (i in 1:Nb_Pop){ 
  Ar[i] = mean(Ar_per_loc[,i])
}

## Mise en forme du tableau final
Tab_Indices_per_pop <- rbind(N, GsurN, Ar, Ho, Hs, Fis, rbarD)
colnames(Tab_Indices_per_pop) <- Pop
Tab_Indices_per_mll <- t(Tab_Indices_per_pop)
kable(Tab_Indices_per_mll, digits = 3)

# Assuming 'ASex_data' is your data frame containing MLG and MLL information
mlg_counts <- aggregate(MLG ~ MLL_poppr, data = ASex_data, FUN = function(x) length(unique(x)))
rownames(mlg_counts) <- mlg_counts[,1]

aSexual_lineages <- merge(mlg_counts,Tab_Indices_per_mll,by="row.names",all.x=TRUE)



```


##G/N and Fis calculation for Mll for Sexual group

```{r}
#create table of genotype

# Select columns with "Mlp" in the name and the first column as isolate id

Sex_data <- genotype_data[genotype_data$Reproduction == "Sex", ]

# Select columns with "Mlp" in the name and the first column as isolate id
genotype_cols_Sex <- c(grep("Mlp", names(Sex_data), value = TRUE))
genotype_Sex <- Sex_data[, genotype_cols_Sex]

#make isolate id as column names 
rownames(genotype_Sex) <- rownames(Sex_data)



# Convert to genind object
data_GenInd_Sex_MLL <- df2genind(
  X = genotype_Sex,   #data.frame containing allele data only 
  sep = NULL,
  ncode = 3,           #an optional integer giving the number of characters used for coding one genotype at one locus.
  ind.names = rownames(genotype_Sex),  # individuals names
  loc.names = colnames(genotype_Sex),  # markers names
  pop = Sex_data$MLL_poppr,                       # giving the population of each individual
  NA.char = "999",                      # string corresponding to missing allele 999 or 999999
  ploidy = 2,
  type = "codom",                       #codom' stands for 'codominant' (e.g. microstallites, allozymes)
  strata = NULL,
  hierarchy = NULL,
  check.ploidy = getOption("adegenet.check.ploidy")
)


data_Genclone_Sex <- as.genclone(data_GenInd_Sex_MLL)

data_Sex_filtered <-filter_stats(data_Genclone_Sex, distance = diss.dist, plot = TRUE, missing = "asis")


#rm (Ar_per_loc, aSexual_lineages, data_Fstat, data_Genclone_ASex, data_Genclone_Sex, data_GenInd_ASex_MLL,
#    data_GenInd_Cluster, data_GenInd_Sex_MLL, fstat_basic_Temporel,mlg_counts, Obj_Ar, Poptmp , 
#    Table_PPR, Temp_Sample)

```


## create table of repeated Mll diffrent years
```{r}

genotype_data$year <- data$Year[match(row.names(genotype_data), data$Isolate)]

# Calculate the frequency of each MLL-Year combination
repeated_MLL_table <- genotype_data [,c("MLL_poppr","year")]
rownames(repeated_MLL_table) <- NULL
# Rename the columns for clarity
colnames(repeated_MLL_table) <- c("MLL",  "year")



# Create an empty list to store the dictionary
mll_year_dict <- list()

# Loop through each row in the repeated_MLL_table
for (i in 1:nrow(repeated_MLL_table)) {
  mll <- repeated_MLL_table$MLL[i]
  year <- repeated_MLL_table$year[i]
  
  # If the MLL is not yet in the dictionary, add it with the current year
  if (!(mll %in% names(mll_year_dict))) {
    mll_year_dict[[as.character(mll)]] <- list(year)
  } else {
    # If the MLL is already in the dictionary, append the year to its list
    mll_year_dict[[as.character(mll)]] <- c(mll_year_dict[[as.character(mll)]], year)
  }
}

# Print the dictionary
print(mll_year_dict)
mll_year_dict["915"]

# Convert the dictionary to a dataframe
mll_year_df <- data.frame(
  MLL = as.integer(names(mll_year_dict)),
  Years = sapply(mll_year_dict, paste, collapse = ", ")
)



# Create a new column to store the counts
mll_year_df$YearCount <- NA

# Loop through each row in repeated_MLL_table
for (i in 1:nrow(mll_year_df)) {
  # Filter the mll_year_df for the current MLL
  filtered_df <- mll_year_df[mll_year_df$MLL == mll_year_df$MLL[i], ]
  
  # Count how many years are associated with the current MLL
  years_count <- length(unlist(strsplit(filtered_df$Years, ", ")))
  
  # Assign the count to the YearCount column
  mll_year_df$YearCount[i] <- years_count
}

# Loop through each row in repeated_MLL_table
for (i in 1:nrow(repeated_MLL_table)) {
  # Filter the mll_year_df for the current MLL
  filtered_df <- mll_year_df[mll_year_df$MLL == repeated_MLL_table$MLL[i], ]
  
  # Get unique years associated with the current MLL
  unique_years <- unique(unlist(strsplit(filtered_df$Years, ", ")))
  
  # Combine unique years into a single string
  years_string <- paste(unique_years, collapse = ", ")
  
  # Assign the combined years to the Years column in mll_year_df
  mll_year_df[mll_year_df$MLL == repeated_MLL_table$MLL[i], "Years"] <- years_string
}

#remove all non repeated mll  
mll_year_df <- mll_year_df[!(mll_year_df$YearCount == 1), ]

#test
mll_year_df [mll_year_df$MLL == 1, ]


# Print the contingency table
write.table(mll_year_df, file = "filtered_mll_years.csv", sep = ",", quote = FALSE, row.names = FALSE)
```


##corss validation to define Profile

```{r}
for (i in 1:nrow(mll_year_df)) {
  if (mll_year_df$YearCount[i] >= 3) {
    mll <- mll_year_df[mll_year_df$MLL == mll_year_df$MLL[i], ]
    years_string <- mll$Years
    years <- unlist(strsplit(years_string, ", "))
    num_years <- length(unique(years))  # Count unique years
    
    if (num_years >= 2) {
      mll_year_df$profile[i] <- "Asex"
    } else {
      mll_year_df$profile[i] <- "Sex"
    }
  } else {
    mll_year_df$profile[i] <- "Sex"
  }
}



for (i in 1:nrow(mll_year_df)) {
  mll_value <- mll_year_df$MLL[i]
  profile_value <- mll_year_df$profile[i]
  
  genotype_data$profile[genotype_data$MLL_poppr == mll_value] <- profile_value
}

genotype_data[is.na(genotype_data$profile), "profile"] <- "Sex"


```


##G/N and Fis calculation for new profile groups

```{r}

# Select columns with "Mlp" in the name and the first column as isolate id
genotype_cols <- c(grep("Mlp", names(genotype_data), value = TRUE))
genotype_mlp <- data[, genotype_cols]

#make isolate id as column names 
rownames(genotype_mlp) <- rownames(genotype_data)



# Convert to genind object
final_GenInd <- df2genind(
  X = genotype_mlp,   #data.frame containing allele data only 
  sep = NULL,
  ncode = 3,           #an optional integer giving the number of characters used for coding one genotype at one locus.
  ind.names = rownames(genotype_mlp),  # individuals names
  loc.names = colnames(genotype_mlp),  # markers names
  pop = genotype_data$profile,                       # giving the population of each individual
  NA.char = "999",                      # string corresponding to missing allele 999 or 999999
  ploidy = 2,
  type = "codom",                       #codom' stands for 'codominant' (e.g. microstallites, allozymes)
  strata = NULL,
  hierarchy = NULL,
  check.ploidy = getOption("adegenet.check.ploidy")
)


Nb_Pop = length(levels(final_GenInd@pop))

# Attribution des différents vecteurs que l'on souhaite calculer
N <- vector(mode ="integer", length = Nb_Pop)
GsurN<- vector(mode ="numeric", length = Nb_Pop)
Ho <- vector(mode ="numeric", length = Nb_Pop)
Hs <- vector(mode ="numeric", length = Nb_Pop)
Fis <- vector(mode ="numeric", length = Nb_Pop)
rbarD<- vector(mode ="numeric", length = Nb_Pop)
Fis_sd <- vector(mode ="numeric", length = Nb_Pop)

Pop <- levels(final_GenInd$pop)

## Utilisation de Poppr pour récupérer les premiers indices N, G/N et rbarD
Table_PPR <- poppr(final_GenInd) # marche bien

rbarD <- Table_PPR$rbarD[1:Nb_Pop]
N <- Table_PPR$N[1:Nb_Pop]
GsurN <- (Table_PPR$MLG[1:Nb_Pop]-1)/(Table_PPR$N[1:Nb_Pop]-1)

#calcul de la proba de DL
ProbaLD <- vector(mode ="numeric", length = Nb_Pop)
for (i in 1:Nb_Pop) {
  Temp_Sample <- popsub(final_GenInd, Table_PPR$Pop[i])
  ProbaLD[i] = ia(Temp_Sample, sample = 999, plot = F)[4] # Attention c'est assez long à tourner 
}


## Utilisation de Fstat pour calculer les autres indices HO, HE, Fis et Ar

data_Fstat <-genind2hierfstat(final_GenInd)

# Boucles qui permet de calculer les indices souhaités pour chaque population (et pas la globalité)
a =0
for (i in levels(data_Fstat$pop) ){
  Poptmp <- final_GenInd[which(final_GenInd$pop==i),]
  #Poptmp  <-genind2hierfstat(Poptmp)
  fstat_basic_Temporel <- basic.stats(Poptmp)
  a = a+1
  Ho[a]<-fstat_basic_Temporel$overall["Ho"]  
  Hs[a]<-fstat_basic_Temporel$overall["Hs"]  
  Fis[a]<-fstat_basic_Temporel$overall["Fis"] 
  Fis_sd[a]<- sd(fstat_basic_Temporel$perloc$Fis)
}

# calcul de la richess allélique
Obj_Ar <- allelic.richness(data_Fstat[which(data_Fstat[,"pop"]!="NA"),])
Ar_per_loc <- Obj_Ar$Ar
#Ar_per_loc <- Ar_per_loc[c(1:2, 4:13, 15:23),] # pour sortir les locus 100 et 26 qui sont absents de certaines pops
Ar<- vector(mode ="numeric", length = Nb_Pop)
for (i in 1:Nb_Pop){ 
  Ar[i] = mean(Ar_per_loc[,i])
}

## Mise en forme du tableau final
Tab_Indices_per_pop <- rbind(N, GsurN, Ar, Ho, Hs, Fis, rbarD,Fis_sd)
colnames(Tab_Indices_per_pop) <- Pop
Tab_Indices_per_pop <- t(Tab_Indices_per_pop)
kable(Tab_Indices_per_pop, digits = 3)

#save the result 
write.table(genotype_data, file = "new_genotype_data.csv", sep = ",", quote = FALSE, row.names = TRUE)


rm (Ar_per_loc, data_Fstat, fstat_basic_Temporel, Obj_Ar, Poptmp , Table_PPR, Temp_Sample)

```



##G/N and Fis calculation for Mll for Asex group (as Profile)

```{r}
#create table of genotype

# Select columns with "Mlp" in the name and the first column as isolate id

ASex_data <- genotype_data[genotype_data$profile == "Asex", ]

# Select columns with "Mlp" in the name and the first column as isolate id
genotype_cols_ASex <- c(grep("Mlp", names(ASex_data), value = TRUE))
genotype_ASex <- ASex_data[, genotype_cols_ASex]

#make isolate id as column names 
rownames(genotype_ASex) <- rownames(ASex_data)



# Convert to genind object
data_GenInd_ASex_MLL <- df2genind(
  X = genotype_ASex,   #data.frame containing allele data only 
  sep = NULL,
  ncode = 3,           #an optional integer giving the number of characters used for coding one genotype at one locus.
  ind.names = rownames(genotype_ASex),  # individuals names
  loc.names = colnames(genotype_ASex),  # markers names
  pop = ASex_data$MLL_poppr,                       # giving the population of each individual
  NA.char = "999",                      # string corresponding to missing allele 999 or 999999
  ploidy = 2,
  type = "codom",                       #codom' stands for 'codominant' (e.g. microstallites, allozymes)
  strata = NULL,
  hierarchy = NULL,
  check.ploidy = getOption("adegenet.check.ploidy")
)
data_Genclone_ASex <- as.genclone(data_GenInd_ASex_MLL)

data_Sex_filtered <-filter_stats(data_Genclone_ASex, distance = diss.dist, plot = TRUE, missing = "asis")

Nb_Pop = length(levels(data_GenInd_ASex_MLL@pop))

# Attribution des différents vecteurs que l'on souhaite calculer
N <- vector(mode ="integer", length = Nb_Pop)
GsurN<- vector(mode ="numeric", length = Nb_Pop)
Ho <- vector(mode ="numeric", length = Nb_Pop)
Hs <- vector(mode ="numeric", length = Nb_Pop)
Fis <- vector(mode ="numeric", length = Nb_Pop)
rbarD<- vector(mode ="numeric", length = Nb_Pop)

Pop <- levels(data_GenInd_ASex_MLL$pop)

## Utilisation de Poppr pour récupérer les premiers indices N, G/N et rbarD
Table_PPR <- poppr(data_GenInd_ASex_MLL) # marche bien

rbarD <- Table_PPR$rbarD[1:Nb_Pop]
N <- Table_PPR$N[1:Nb_Pop]
GsurN <- (Table_PPR$MLG[1:Nb_Pop]-1)/(Table_PPR$N[1:Nb_Pop]-1)

#calcul de la proba de DL
ProbaLD <- vector(mode ="numeric", length = Nb_Pop)
for (i in 1:Nb_Pop) {
  Temp_Sample <- popsub(data_GenInd_ASex_MLL, Table_PPR$Pop[i])
  ProbaLD[i] = ia(Temp_Sample, sample = 999, plot = F)[4] # Attention c'est assez long à tourner 
}


## Utilisation de Fstat pour calculer les autres indices HO, HE, Fis et Ar

data_Fstat <-genind2hierfstat(data_GenInd_ASex_MLL)

# Boucles qui permet de calculer les indices souhaités pour chaque population (et pas la globalité)
a =0
for (i in levels(data_Fstat$pop) ){
  Poptmp <- data_GenInd_ASex_MLL[which(data_GenInd_ASex_MLL$pop==i),]
  #Poptmp  <-genind2hierfstat(Poptmp)
  fstat_basic_Temporel <- basic.stats(Poptmp)
  a = a+1
  Ho[a]<-fstat_basic_Temporel$overall["Ho"]  
  Hs[a]<-fstat_basic_Temporel$overall["Hs"]  
  Fis[a]<-fstat_basic_Temporel$overall["Fis"] 
}

# calcul de la richess allélique
Obj_Ar <- allelic.richness(data_Fstat[which(data_Fstat[,"pop"]!="NA"),])
Ar_per_loc <- Obj_Ar$Ar
#Ar_per_loc <- Ar_per_loc[c(1:2, 4:13, 15:23),] # pour sortir les locus 100 et 26 qui sont absents de certaines pops
Ar<- vector(mode ="numeric", length = Nb_Pop)
for (i in 1:Nb_Pop){ 
  Ar[i] = mean(Ar_per_loc[,i])
}

## Mise en forme du tableau final
Tab_Indices_per_pop <- rbind(N, GsurN, Ar, Ho, Hs, Fis, rbarD)
colnames(Tab_Indices_per_pop) <- Pop
Tab_Indices_per_mll <- t(Tab_Indices_per_pop)
kable(Tab_Indices_per_mll, digits = 3)

# Assuming 'ASex_data' is your data frame containing MLG and MLL information
mlg_counts <- aggregate(MLG ~ MLL_poppr, data = ASex_data, FUN = function(x) length(unique(x)))
rownames(mlg_counts) <- mlg_counts[,1]

aSexual_lineages <- merge(mlg_counts,Tab_Indices_per_mll,by="row.names",all.x=TRUE)



```



##G/N and Fis calculation for Mll for Sexual group (as profile)

```{r}
#create table of genotype

# Select columns with "Mlp" in the name and the first column as isolate id

Sex_data <- genotype_data[genotype_data$profile== "Sex", ]

# Select columns with "Mlp" in the name and the first column as isolate id
genotype_cols_Sex <- c(grep("Mlp", names(Sex_data), value = TRUE))
genotype_Sex <- Sex_data[, genotype_cols_Sex]

#make isolate id as column names 
rownames(genotype_Sex) <- rownames(Sex_data)



# Convert to genind object
data_GenInd_Sex_MLL <- df2genind(
  X = genotype_Sex,   #data.frame containing allele data only 
  sep = NULL,
  ncode = 3,           #an optional integer giving the number of characters used for coding one genotype at one locus.
  ind.names = rownames(genotype_Sex),  # individuals names
  loc.names = colnames(genotype_Sex),  # markers names
  pop = Sex_data$MLL_poppr,                       # giving the population of each individual
  NA.char = "999",                      # string corresponding to missing allele 999 or 999999
  ploidy = 2,
  type = "codom",                       #codom' stands for 'codominant' (e.g. microstallites, allozymes)
  strata = NULL,
  hierarchy = NULL,
  check.ploidy = getOption("adegenet.check.ploidy")
)


data_Genclone_Sex <- as.genclone(data_GenInd_Sex_MLL)

data_Sex_filtered <-filter_stats(data_Genclone_Sex, distance = diss.dist, plot = TRUE, missing = "asis")


rm (Ar_per_loc, aSexual_lineages, data_Fstat, data_Genclone_ASex, data_Genclone_Sex, data_GenInd_ASex_MLL,
    data_GenInd_Cluster, data_GenInd_Sex_MLL, fstat_basic_Temporel,mlg_counts, Obj_Ar, Poptmp , 
    Table_PPR, Temp_Sample)

```



## 3. Ascending order for fixation of MLL

```{r}

# Calculate the frequency of each MLL combination
count_MLL_table <- data.frame(MLL_poppr = unique(genotype_data$MLL_poppr), Count = NA)

for (i in 1:nrow(count_MLL_table)) {
  mll_value <- count_MLL_table$MLL_poppr[i]
  count_MLL_table$Count[i] <- sum(genotype_data$MLL_poppr == mll_value)
}

# Sort the dataframe in descending order by the "Count" column
count_MLL_table <- count_MLL_table[order(-count_MLL_table$Count), ]

# Create a new column "N" with values in ascending order
count_MLL_table$N <- 1:nrow(count_MLL_table)

# Add row names to count_MLL_table
rownames(count_MLL_table) <- NULL

# Create a temporary column with row names for genotype_data
genotype_data$temp_row_names <- rownames(genotype_data)

# Merge the "count_MLL_table" dataframe with the original "genotype_data" dataframe
genotype_data <- merge(genotype_data, count_MLL_table, by = "MLL_poppr", all.x = TRUE)

# Restore the original row names
rownames(genotype_data) <- genotype_data$temp_row_names

# Remove the temporary column
genotype_data$temp_row_names <- NULL
#genotype_data$MLL_poppr <- NULL

# Rename the "N" column to "new_MLL"
colnames(genotype_data)[colnames(genotype_data) == "N"] <- "new_MLL"


# Ascending order 
genotype_data <- genotype_data[order(genotype_data$new_MLL),]


#save the result 
write.xlsx(genotype_data,"new_genotype_data.xlsx", rowNames = TRUE)


```



##  try NJ it with popper
 
```{r}
# Convert to genind object
final_GenInd <- df2genind(
  X = genotype_mlp,   #data.frame containing allele data only 
  sep = NULL,
  ncode = 3,           #an optional integer giving the number of characters used for coding one genotype at one locus.
  ind.names = rownames(genotype_mlp),  # individuals names
  loc.names = colnames(genotype_mlp),  # markers names
  pop = genotype_data$new_MLL,                       # giving the population of each individual
  NA.char = "999",                      # string corresponding to missing allele 999 or 999999
  ploidy = 2,
  type = "codom",                       #codom' stands for 'codominant' (e.g. microstallites, allozymes)
  strata = NULL,
  hierarchy = NULL,
  check.ploidy = getOption("adegenet.check.ploidy")
)


# Calculate distance matrix and build NJ tree

dist <- diss.dist(final_GenInd)
tree <- nj(dist)
tree2 <- aboot(final_GenInd, dist = diss.dist , tree = "upgma", missing = "asis")

# Create group information based on 'Profil' column
groupInfo <- split(rownames(genotype_data), genotype_data$profile)

# Group the tree labels based on the group information
tree <- groupOTU(tree2, groupInfo)


# Create the ggtree plot with circular layout
options(ignore.negative.edge=TRUE)
p <- ggtree(tree, aes(color = group), layout="circular") +
  labs(color = "Profile") +
  # ... other plot customization here ...
  theme(
    panel.background = element_rect(fill='transparent'), # transparent panel bg
    plot.background = element_rect(fill='transparent', color=NA), # transparent plot bg
    panel.grid.major = element_blank(), # remove major gridlines
    panel.grid.minor = element_blank(), # remove minor gridlines
    legend.background = element_rect(fill='transparent'), # transparent legend bg
    legend.box.background = element_rect(fill='transparent'), # transparent legend panel
    legend.text = element_text(color = 'black', face = 'bold', size = 13), # set legend text color and size
    legend.title = element_text(color = 'black', face = 'bold', size = 15) # set legend title color and size

  )

p 

# Create a dataframe for annotation
dat1 <- data.frame(
  ID = rownames(genotype_data),
  MLL = genotype_data$new_MLL,
  Group = genotype_data$profile,
  Year = as.factor(data$Year),
  Location = data$Region

)

# Use %<+% of ggtree to add annotation dataset to the tree
p1 <- p  %<+% dat1


# Initialize fill scale using new_scale_fill() from ggnewscale package
p2 <- p +
  geom_fruit(
    data = dat1,
    geom = geom_col,
    mapping = aes(y = ID, x = Year, fill = Location),  # Map 'Location' to fill
    pwidth = 0.4,
    offset = 0.01,
    axis.params = list(
      axis = "x",  # Add x-axis text
      text.angle = -45,  # Adjust text angle
      hjust = 0,  # Adjust horizontal position
      text.size = 3,
      line.size = 0.4,
      line.color = "black"
    ),
    grid.params = list(color = "black", linetype = 5, size = 0.4, alpha = 0.8)  # Add grid lines
  ) +
  scale_shape_manual(
    values = 1:length(unique(dat1$Location))  # Set shape values
  ) + # Customize the color gradient
  theme(
    panel.background = element_rect(fill='transparent'), # transparent panel bg
    plot.background = element_rect(fill='transparent', color=NA), # transparent plot bg
    panel.grid.major = element_blank(), # remove major gridlines
    panel.grid.minor = element_blank(), # remove minor gridlines
    legend.background = element_rect(fill='transparent'), # transparent legend bg
    legend.box.background = element_rect(fill='transparent'), # transparent legend panel
    legend.text = element_text(color = 'black', face = 'bold', size = 13), # set legend text color and size
    legend.title = element_text(color = 'black', face = 'bold', size = 15) # set legend title color and size

  ) 

   #+ geom_treescale(fontsize=2, linesize=0.3, x=-10, y=1000)

# Modify legend titles
p2 <- p2 +
  labs(fill = "Location", color = "Profile") 

p2

ggsave("tree_plot1.png", p, width = 17, height = 8, dpi = 600, bg = "transparent")  # Save the plot with desired dimensions

ggsave("tree_plot2.png", p2, width = 17, height = 8, dpi = 600, bg = "transparent")  # Save the plot with desired dimensions

```



## 4. Data map visualization

just to look at where each population is located 

```{r}
# summarize data by population and location

genotype_data$Pop <- data$Pop
genotype_data$Long <- data$Long
genotype_data$Lat <- data$Lat
  

pop_data <- genotype_data %>%
  group_by(Pop, Long, Lat, profile) %>%
  summarize(n = n(), .groups = "drop") %>%   # Specify .groups = "drop" to remove grouping
  mutate(percent = n / sum(n)) %>%
  select(Pop, Long, Lat, profile, n, percent)


#draw map Representative the popular individual across France map within reproductive mode
# The area of the France Region;
xlim <- c(-4.3,9.1)
ylim <- c(41, 51)

# Creates an xyz object for use with the function draw.pie
xyz <- make.xyz(pop_data$Long, pop_data$Lat, pop_data$percent, pop_data$profile)

# Create a color palette based on the unique profile values
unique_profiles <- unique(pop_data$profile)
num_profiles <- length(unique_profiles)
my_colors <- viridis(num_profiles)

# Create a named vector to map profiles to colors
#profile_color_mapping <- setNames(my_colors, unique_profiles)

# Create a named vector for profile colors
profile_color_mapping <- c("ASex" = "#fb786e",  "Sex" = "#01bec4"  )
transparent_colors <- adjustcolor(profile_color_mapping, alpha.f = 0.8)


# The plot of the pie chart above the map
# Start the png device

png(filename = "map_output.png", width = 1000, height = 800, bg = "transparent")

par(mai = c(0.5, 0.5, 0.35, 0.2), omi = c(0.25, 0.5, 0, 0),
    mgp = c(2.5, 0.5, 0), family = "Arial",col = "black")
basemap(xlim = c(-4.3, 9.1), ylim = c(41, 51), bg = "transparent",
        main = "Distribution of population of poplar rust in France", col.main="white", cex.main = 1.6)
map("france", fill = FALSE, col = "black", xlim = xlim, ylim = ylim, add = TRUE)
final_map <- draw.pie(xyz$x, xyz$y, xyz$z, radius = 0.3, col = transparent_colors)

legend(-4.5, 45, legend = c("Asex", "Sex"), fill = transparent_colors, bty = "n", cex = 2, ncol = 1, text.col = "black")


dev.off()


```

#convert data to genepop IBD data

```{r}
# Set 'Isolate' as row names
rownames(data) <- data$Isolate

# Ensure the 'Isolate' column matches row names in genotype_data
data <- data[match(rownames(genotype_data), data$Isolate), ]

# Add longitude and latitude to genotype_data
genotype_data$Long <- data$Long
genotype_data$Lat <- data$Lat

# Separate Sex and Asex
Temp_Sex_data <- genotype_data[genotype_data$Reproduction== "Sex", ]
Temp_Asex_data <- genotype_data[genotype_data$Reproduction== "Asex", ]

# Extract relevant columns: marker data and geographic coordinates
marker_data_sex <- Temp_Sex_data[, grep("^Mlp_", colnames(Temp_Sex_data))]
geo_data_sex <- Temp_Sex_data[, c("Long", "Lat")]


# Combine marker data with geographic coordinates
combined_data_sex <- cbind(geo_data_sex, marker_data_sex)

# Sort data by coordinates
combined_data_sex <- combined_data[order(combined_data$Long, combined_data$Lat), ]

# Create Genepop formatted data
genepop_format <- function(data) {
  # Initialize result with the title line for Genepop file
  result <- c("Title line for Genepop file")
  
  # Add marker names, each on a new line
  markers <- colnames(data)[-c(1, 2)]
  result <- c(result, markers)
  
  # Extract unique coordinates
  unique_coords <- unique(data[, c("Long", "Lat")])
  
  # Process each unique coordinate
  for (i in 1:nrow(unique_coords)) {
    # Add population indicator
    result <- c(result, "Pop")
    
    # Get rows corresponding to the current unique coordinate
    coord <- unique_coords[i, ]
    coord_data <- data[data$Long == coord$Long & data$Lat == coord$Lat, ]
    
    # Format each row
    for (j in 1:nrow(coord_data)) {
      ind_data <- paste(coord_data[j, 1], coord_data[j, 2], ",", paste(coord_data[j, -c(1, 2)], collapse = " "))
      result <- c(result, ind_data)
    }
  }
  
  return(result)
}
# Generate Genepop formatted lines
genepop_lines <- genepop_format(combined_data_sex)

# Write to a Genepop file
writeLines(genepop_lines, "genetic_data.txt")

# Print the Genepop formatted lines (for checking)
#cat(genepop_lines, sep = "\n")

```


#Mental test IBD (assess the correlation between genetic and geographic distance matrices)

```{r}
# Define the path to your input Genepop file
input_file <- "genetic_data.txt"

# Define the path for the output file
output_file <- "genetic_data.iso"

locinfile <- genepopExample('w2.txt')


ibd(
  inputFile = input_file,
  outputFile = output_file,
  dataType = "Diploid",  # Specify the data type
  statistic = "e",  # Specify the statistic to use
  geographicScale = "2D",  # Specify the geographic scale
)

# Print the output file path
cat("IBD analysis output saved to:", outputFile, "\n")

```


